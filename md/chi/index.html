<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta http-equiv="content-type" content="text/html;charset=utf-8">
		<meta content="always" name="referrer">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>go-chi/chi: lightweight, idiomatic and composable router for building Go HTTP services</title>
        <meta name="description" content="lightweight, idiomatic and composable router for building Go HTTP services - go-chi/chi: lightweight, idiomatic and composable router for building Go HTTP services">


        <link rel="stylesheet" href="/css/vscode/default.css" >
        <link rel="stylesheet" href="/css/vscode/markdown.css" >
        <link rel="stylesheet" href="/css/vscode/highlight.css" >
        
    </head>

    <body class="vscode-body scrollBeyondLastLine wordWrap showEditorSelection vscode-dark" >

        <h1 data-line="0" class="code-line">
            <img alt="chi" src="/res/svg/go-chi_logo.svg" width="220">
        </h1>

        <p data-line="3" class="code-line">
            <a href="https://pkg.go.dev/github.com/go-chi/chi?tab=versions" >
                <img src="/res/svg/go-chi_chi_status.svg" alt="GoDoc Widget"></a>
            <a href="https://travis-ci.org/go-chi/chi" >
                <img src="/res/svg/go-chi_chi_travis_master.svg" alt="Travis Widget" ></a>
        </p>



<p data-line="5" class="code-line"><code>chi</code> is a lightweight, idiomatic and composable router for building Go HTTP services. It's
especially good at helping you write large REST API services that are kept maintainable as your
project grows and changes. <code>chi</code> is built on the new <code>context</code> package introduced in Go 1.7 to
handle signaling, cancelation and request-scoped values across a handler chain.</p>
<p data-line="10" class="code-line">The focus of the project has been to seek out an elegant and comfortable design for writing
REST API servers, written during the development of the Pressly API service that powers our
public API service, which in turn powers all of our client-side applications.</p>
<p data-line="14" class="code-line">The key considerations of chi's design are: project structure, maintainability, standard http
handlers (stdlib-only), developer productivity, and deconstructing a large system into many small
parts. The core router <code>github.com/go-chi/chi</code> is quite small (less than 1000 LOC), but we've also
included some useful/optional subpackages: <a href="/middleware" data-href="/middleware" title="/middleware">middleware</a>, <a href="https://github.com/go-chi/render" data-href="https://github.com/go-chi/render" title="https://github.com/go-chi/render">render</a>
and <a href="https://github.com/go-chi/docgen" data-href="https://github.com/go-chi/docgen" title="https://github.com/go-chi/docgen">docgen</a>. We hope you enjoy it too!</p>
<h2 id="install" data-line="20" class="code-line">Install</h2>
<p data-line="22" class="code-line"><code>go get -u github.com/go-chi/chi/v5</code></p>
<h2 id="features" data-line="25" class="code-line">Features</h2>
<ul>
<li data-line="27" class="code-line"><strong>Lightweight</strong> - cloc'd in ~1000 LOC for the chi router</li>
<li data-line="28" class="code-line"><strong>Fast</strong> - yes, see <a href="#benchmarks" data-href="#benchmarks" title="#benchmarks">benchmarks</a></li>
<li data-line="29" class="code-line"><strong>100% compatible with net/http</strong> - use any http or middleware pkg in the ecosystem that is also compatible with <code>net/http</code></li>
<li data-line="30" class="code-line"><strong>Designed for modular/composable APIs</strong> - middlewares, inline middlewares, route groups and sub-router mounting</li>
<li data-line="31" class="code-line"><strong>Context control</strong> - built on new <code>context</code> package, providing value chaining, cancellations and timeouts</li>
<li data-line="32" class="code-line"><strong>Robust</strong> - in production at Pressly, CloudFlare, Heroku, 99Designs, and many others (see <a href="https://github.com/go-chi/chi/issues/91" data-href="https://github.com/go-chi/chi/issues/91" title="https://github.com/go-chi/chi/issues/91">discussion</a>)</li>
<li data-line="33" class="code-line"><strong>Doc generation</strong> - <code>docgen</code> auto-generates routing documentation from your source to JSON or Markdown</li>
<li data-line="34" class="code-line"><strong>Go.mod support</strong> - as of v5, go.mod support (see <a href="https://github.com/go-chi/chi/blob/master/CHANGELOG.md" data-href="https://github.com/go-chi/chi/blob/master/CHANGELOG.md" title="https://github.com/go-chi/chi/blob/master/CHANGELOG.md">CHANGELOG</a>)</li>
<li data-line="35" class="code-line"><strong>No external dependencies</strong> - plain ol' Go stdlib + net/http</li>
</ul>
<h2 id="examples" data-line="38" class="code-line">Examples</h2>
<p data-line="40" class="code-line">See <a href="https://github.com/go-chi/chi/blob/master/_examples/" data-href="https://github.com/go-chi/chi/blob/master/_examples/" title="https://github.com/go-chi/chi/blob/master/_examples/">_examples/</a> for a variety of examples.</p>
<p data-line="43" class="code-line"><strong>As easy as:</strong></p>

<pre><code data-line="45" class="code-line language-go"><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"net/http"</span>

    <span class="hljs-string">"github.com/go-chi/chi/v5"</span>
    <span class="hljs-string">"github.com/go-chi/chi/v5/middleware"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    r := chi.NewRouter()
    r.Use(middleware.Logger)
    r.Get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
        w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"welcome"</span>))
    })
    http.ListenAndServe(<span class="hljs-string">":3000"</span>, r)
}
</div></code></pre>


<p data-line="65" class="code-line"><strong>REST Preview:</strong></p>
<p data-line="67" class="code-line">Here is a little preview of how routing looks like with chi. Also take a look at the generated routing docs
in JSON (<a href="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.json" data-href="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.json" title="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.json">routes.json</a>) and in
Markdown (<a href="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.md" data-href="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.md" title="https://github.com/go-chi/chi/blob/master/_examples/rest/routes.md">routes.md</a>).</p>
<p data-line="71" class="code-line">I highly recommend reading the source of the <a href="https://github.com/go-chi/chi/blob/master/_examples/" data-href="https://github.com/go-chi/chi/blob/master/_examples/" title="https://github.com/go-chi/chi/blob/master/_examples/">examples</a> listed
above, they will show you all the features of chi and serve as a good form of documentation.</p>
<pre><code data-line="74" class="code-line language-go"><div><span class="hljs-keyword">import</span> (
<span class="hljs-comment">//...</span>
<span class="hljs-string">"context"</span>
<span class="hljs-string">"github.com/go-chi/chi/v5"</span>
<span class="hljs-string">"github.com/go-chi/chi/v5/middleware"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
r := chi.NewRouter()

<span class="hljs-comment">// A good base middleware stack</span>
r.Use(middleware.RequestID)
r.Use(middleware.RealIP)
r.Use(middleware.Logger)
r.Use(middleware.Recoverer)

<span class="hljs-comment">// Set a timeout value on the request context (ctx), that will signal</span>
<span class="hljs-comment">// through ctx.Done() that the request has timed out and further</span>
<span class="hljs-comment">// processing should be stopped.</span>
r.Use(middleware.Timeout(<span class="hljs-number">60</span> * time.Second))

r.Get(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">"hi"</span>))
})

<span class="hljs-comment">// RESTy routes for "articles" resource</span>
r.Route(<span class="hljs-string">"/articles"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r chi.Router)</span></span> {
r.With(paginate).Get(<span class="hljs-string">"/"</span>, listArticles)                           <span class="hljs-comment">// GET /articles</span>
r.With(paginate).Get(<span class="hljs-string">"/{month}-{day}-{year}"</span>, listArticlesByDate) <span class="hljs-comment">// GET /articles/01-16-2017</span>

r.Post(<span class="hljs-string">"/"</span>, createArticle)                                        <span class="hljs-comment">// POST /articles</span>
r.Get(<span class="hljs-string">"/search"</span>, searchArticles)                                  <span class="hljs-comment">// GET /articles/search</span>

<span class="hljs-comment">// Regexp url parameters:</span>
r.Get(<span class="hljs-string">"/{articleSlug:[a-z-]+}"</span>, getArticleBySlug)                <span class="hljs-comment">// GET /articles/home-is-toronto</span>

<span class="hljs-comment">// Subrouters:</span>
r.Route(<span class="hljs-string">"/{articleID}"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r chi.Router)</span></span> {
r.Use(ArticleCtx)
r.Get(<span class="hljs-string">"/"</span>, getArticle)                                          <span class="hljs-comment">// GET /articles/123</span>
r.Put(<span class="hljs-string">"/"</span>, updateArticle)                                       <span class="hljs-comment">// PUT /articles/123</span>
r.Delete(<span class="hljs-string">"/"</span>, deleteArticle)                                    <span class="hljs-comment">// DELETE /articles/123</span>
})
})

<span class="hljs-comment">// Mount the admin sub-router</span>
r.Mount(<span class="hljs-string">"/admin"</span>, adminRouter())

http.ListenAndServe(<span class="hljs-string">":3333"</span>, r)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ArticleCtx</span><span class="hljs-params">(next http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> {
<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
articleID := chi.URLParam(r, <span class="hljs-string">"articleID"</span>)
article, err := dbGetArticle(articleID)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
http.Error(w, http.StatusText(<span class="hljs-number">404</span>), <span class="hljs-number">404</span>)
<span class="hljs-keyword">return</span>
}
ctx := context.WithValue(r.Context(), <span class="hljs-string">"article"</span>, article)
next.ServeHTTP(w, r.WithContext(ctx))
})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getArticle</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
ctx := r.Context()
article, ok := ctx.Value(<span class="hljs-string">"article"</span>).(*Article)
<span class="hljs-keyword">if</span> !ok {
http.Error(w, http.StatusText(<span class="hljs-number">422</span>), <span class="hljs-number">422</span>)
<span class="hljs-keyword">return</span>
}
w.Write([]<span class="hljs-keyword">byte</span>(fmt.Sprintf(<span class="hljs-string">"title:%s"</span>, article.Title)))
}

<span class="hljs-comment">// A completely separate router for administrator routes</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adminRouter</span><span class="hljs-params">()</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> {
r := chi.NewRouter()
r.Use(AdminOnly)
r.Get(<span class="hljs-string">"/"</span>, adminIndex)
r.Get(<span class="hljs-string">"/accounts"</span>, adminListAccounts)
<span class="hljs-keyword">return</span> r
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AdminOnly</span><span class="hljs-params">(next http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> {
<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
ctx := r.Context()
perm, ok := ctx.Value(<span class="hljs-string">"acl.permission"</span>).(YourPermissionType)
<span class="hljs-keyword">if</span> !ok || !perm.IsAdmin() {
http.Error(w, http.StatusText(<span class="hljs-number">403</span>), <span class="hljs-number">403</span>)
<span class="hljs-keyword">return</span>
}
next.ServeHTTP(w, r)
})
}
</div></code></pre>
<h2 id="router-interface" data-line="172" class="code-line">Router interface</h2>
<p data-line="174" class="code-line">chi's router is based on a kind of <a href="https://en.wikipedia.org/wiki/Radix_tree" data-href="https://en.wikipedia.org/wiki/Radix_tree" title="https://en.wikipedia.org/wiki/Radix_tree">Patricia Radix trie</a>.
The router is fully compatible with <code>net/http</code>.</p>
<p data-line="177" class="code-line">Built on top of the tree is the <code>Router</code> interface:</p>
<pre><code data-line="179" class="code-line language-go"><div><span class="hljs-comment">// Router consisting of the core routing methods used by chi's Mux,</span>
<span class="hljs-comment">// using only the standard net/http.</span>
<span class="hljs-keyword">type</span> Router <span class="hljs-keyword">interface</span> {
http.Handler
Routes

<span class="hljs-comment">// Use appends one or more middlewares onto the Router stack.</span>
Use(middlewares ...<span class="hljs-keyword">func</span>(http.Handler) http.Handler)

<span class="hljs-comment">// With adds inline middlewares for an endpoint handler.</span>
With(middlewares ...<span class="hljs-keyword">func</span>(http.Handler) http.Handler) Router

<span class="hljs-comment">// Group adds a new inline-Router along the current routing</span>
<span class="hljs-comment">// path, with a fresh middleware stack for the inline-Router.</span>
Group(fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r Router)</span>) <span class="hljs-title">Router</span></span>

<span class="hljs-comment">// Route mounts a sub-Router along a `pattern`` string.</span>
Route(pattern <span class="hljs-keyword">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r Router)</span>) <span class="hljs-title">Router</span></span>

<span class="hljs-comment">// Mount attaches another http.Handler along ./pattern/*</span>
Mount(pattern <span class="hljs-keyword">string</span>, h http.Handler)

<span class="hljs-comment">// Handle and HandleFunc adds routes for `pattern` that matches</span>
<span class="hljs-comment">// all HTTP methods.</span>
Handle(pattern <span class="hljs-keyword">string</span>, h http.Handler)
HandleFunc(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)

<span class="hljs-comment">// Method and MethodFunc adds routes for `pattern` that matches</span>
<span class="hljs-comment">// the `method` HTTP method.</span>
Method(method, pattern <span class="hljs-keyword">string</span>, h http.Handler)
MethodFunc(method, pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)

<span class="hljs-comment">// HTTP-method routing along `pattern`</span>
Connect(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Delete(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Get(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Head(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Options(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Patch(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Post(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Put(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)
Trace(pattern <span class="hljs-keyword">string</span>, h http.HandlerFunc)

<span class="hljs-comment">// NotFound defines a handler to respond whenever a route could</span>
<span class="hljs-comment">// not be found.</span>
NotFound(h http.HandlerFunc)

<span class="hljs-comment">// MethodNotAllowed defines a handler to respond whenever a method is</span>
<span class="hljs-comment">// not allowed.</span>
MethodNotAllowed(h http.HandlerFunc)
}

<span class="hljs-comment">// Routes interface adds two methods for router traversal, which is also</span>
<span class="hljs-comment">// used by the github.com/go-chi/docgen package to generate documentation for Routers.</span>
<span class="hljs-keyword">type</span> Routes <span class="hljs-keyword">interface</span> {
<span class="hljs-comment">// Routes returns the routing tree in an easily traversable structure.</span>
Routes() []Route

<span class="hljs-comment">// Middlewares returns the list of middlewares in use by the router.</span>
Middlewares() Middlewares

<span class="hljs-comment">// Match searches the routing tree for a handler that matches</span>
<span class="hljs-comment">// the method/path - similar to routing a http request, but without</span>
<span class="hljs-comment">// executing the handler thereafter.</span>
Match(rctx *Context, method, path <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span>
}
</div></code></pre>
<p data-line="248" class="code-line">Each routing method accepts a URL <code>pattern</code> and chain of <code>handlers</code>. The URL pattern
supports named params (ie. <code>/users/{userID}</code>) and wildcards (ie. <code>/admin/*</code>). URL parameters
can be fetched at runtime by calling <code>chi.URLParam(r, "userID")</code> for named parameters
and <code>chi.URLParam(r, "*")</code> for a wildcard parameter.</p>
<h3 id="middleware-handlers" data-line="254" class="code-line">Middleware handlers</h3>
<p data-line="256" class="code-line">chi's middlewares are just stdlib net/http middleware handlers. There is nothing special
about them, which means the router and all the tooling is designed to be compatible and
friendly with any middleware in the community. This offers much better extensibility and reuse
of packages and is at the heart of chi's purpose.</p>
<p data-line="261" class="code-line">Here is an example of a standard net/http middleware where we assign a context key <code>"user"</code>
the value of <code>"123"</code>. This middleware sets a hypothetical user identifier on the request
context and calls the next handler in the chain.</p>
<pre><code data-line="265" class="code-line language-go"><div><span class="hljs-comment">// HTTP middleware setting a value on the request context</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyMiddleware</span><span class="hljs-params">(next http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> {
<span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
<span class="hljs-comment">// create new context from `r` request context, and assign key `"user"`</span>
<span class="hljs-comment">// to value of `"123"`</span>
ctx := context.WithValue(r.Context(), <span class="hljs-string">"user"</span>, <span class="hljs-string">"123"</span>)

<span class="hljs-comment">// call the next handler in the chain, passing the response writer and</span>
<span class="hljs-comment">// the updated request object with the new context value.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// note: context.Context values are nested, so any previously set</span>
<span class="hljs-comment">// values will be accessible as well, and the new `"user"` key</span>
<span class="hljs-comment">// will be accessible from this point forward.</span>
next.ServeHTTP(w, r.WithContext(ctx))
})
}
</div></code></pre>
<h3 id="request-handlers" data-line="285" class="code-line">Request handlers</h3>
<p data-line="287" class="code-line">chi uses standard net/http request handlers. This little snippet is an example of a http.Handler
func that reads a user identifier from the request context - hypothetically, identifying
the user sending an authenticated request, validated+set by a previous middleware handler.</p>
<pre><code data-line="291" class="code-line language-go"><div><span class="hljs-comment">// HTTP handler accessing data from the request context.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyRequestHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
<span class="hljs-comment">// here we read from the request context and fetch out `"user"` key set in</span>
<span class="hljs-comment">// the MyMiddleware example above.</span>
user := r.Context().Value(<span class="hljs-string">"user"</span>).(<span class="hljs-keyword">string</span>)

<span class="hljs-comment">// respond to the client</span>
w.Write([]<span class="hljs-keyword">byte</span>(fmt.Sprintf(<span class="hljs-string">"hi %s"</span>, user)))
}
</div></code></pre>
<h3 id="url-parameters" data-line="304" class="code-line">URL parameters</h3>
<p data-line="306" class="code-line">chi's router parses and stores URL parameters right onto the request context. Here is
an example of how to access URL params in your net/http handlers. And of course, middlewares
are able to access the same information.</p>
<pre><code data-line="310" class="code-line language-go"><div><span class="hljs-comment">// HTTP handler accessing the url routing parameters.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyRequestHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
<span class="hljs-comment">// fetch the url parameter `"userID"` from the request of a matching</span>
<span class="hljs-comment">// routing pattern. An example routing pattern could be: /users/{userID}</span>
userID := chi.URLParam(r, <span class="hljs-string">"userID"</span>)

<span class="hljs-comment">// fetch `"key"` from the request context</span>
ctx := r.Context()
key := ctx.Value(<span class="hljs-string">"key"</span>).(<span class="hljs-keyword">string</span>)

<span class="hljs-comment">// respond to the client</span>
w.Write([]<span class="hljs-keyword">byte</span>(fmt.Sprintf(<span class="hljs-string">"hi %v, %v"</span>, userID, key)))
}
</div></code></pre>
<h2 id="middlewares" data-line="327" class="code-line">Middlewares</h2>
<p data-line="329" class="code-line">chi comes equipped with an optional <code>middleware</code> package, providing a suite of standard
<code>net/http</code> middlewares. Please note, any middleware in the ecosystem that is also compatible
with <code>net/http</code> can be used with chi's mux.</p>
<h3 id="core-middlewares" data-line="333" class="code-line">Core middlewares</h3>
<hr>
<table>
<thead>
<tr>
<th style="text-align:left">chi/middleware Handler</th>
<th style="text-align:left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentEncoding" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentEncoding" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentEncoding">AllowContentEncoding</a></td>
<td style="text-align:left">Enforces a whitelist of request Content-Encoding headers</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentType" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentType" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentType">AllowContentType</a></td>
<td style="text-align:left">Explicit whitelist of accepted request Content-Types</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#BasicAuth" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#BasicAuth" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#BasicAuth">BasicAuth</a></td>
<td style="text-align:left">Basic HTTP authentication</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Compress" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Compress" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Compress">Compress</a></td>
<td style="text-align:left">Gzip compression for clients that accept compressed responses</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#ContentCharset" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#ContentCharset" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#ContentCharset">ContentCharset</a></td>
<td style="text-align:left">Ensure charset for Content-Type request headers</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#CleanPath" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#CleanPath" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#CleanPath">CleanPath</a></td>
<td style="text-align:left">Clean double slashes from request path</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#GetHead" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#GetHead" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#GetHead">GetHead</a></td>
<td style="text-align:left">Automatically route undefined HEAD requests to GET handlers</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Heartbeat" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Heartbeat" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Heartbeat">Heartbeat</a></td>
<td style="text-align:left">Monitoring endpoint to check the servers pulse</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Logger" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Logger" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Logger">Logger</a></td>
<td style="text-align:left">Logs the start and end of each request with the elapsed processing time</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#NoCache" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#NoCache" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#NoCache">NoCache</a></td>
<td style="text-align:left">Sets response headers to prevent clients from caching</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Profiler" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Profiler" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Profiler">Profiler</a></td>
<td style="text-align:left">Easily attach net/http/pprof to your routers</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RealIP" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RealIP" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#RealIP">RealIP</a></td>
<td style="text-align:left">Sets a http.Request's RemoteAddr to either X-Real-IP or X-Forwarded-For</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Recoverer" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Recoverer" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Recoverer">Recoverer</a></td>
<td style="text-align:left">Gracefully absorb panics and prints the stack trace</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RequestID" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RequestID" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#RequestID">RequestID</a></td>
<td style="text-align:left">Injects a request ID into the context of each request</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RedirectSlashes" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RedirectSlashes" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#RedirectSlashes">RedirectSlashes</a></td>
<td style="text-align:left">Redirect slashes on routing paths</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RouteHeaders" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#RouteHeaders" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#RouteHeaders">RouteHeaders</a></td>
<td style="text-align:left">Route handling for request headers</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#SetHeader" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#SetHeader" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#SetHeader">SetHeader</a></td>
<td style="text-align:left">Short-hand middleware to set a response header key/value</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#StripSlashes" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#StripSlashes" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#StripSlashes">StripSlashes</a></td>
<td style="text-align:left">Strip slashes on routing paths</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Throttle" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Throttle" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Throttle">Throttle</a></td>
<td style="text-align:left">Puts a ceiling on the number of concurrent requests</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Timeout" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#Timeout" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#Timeout">Timeout</a></td>
<td style="text-align:left">Signals to the request context when the timeout deadline is reached</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#URLFormat" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#URLFormat" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#URLFormat">URLFormat</a></td>
<td style="text-align:left">Parse extension from url and put it on request context</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://pkg.go.dev/github.com/go-chi/chi/middleware#WithValue" data-href="https://pkg.go.dev/github.com/go-chi/chi/middleware#WithValue" title="https://pkg.go.dev/github.com/go-chi/chi/middleware#WithValue">WithValue</a></td>
<td style="text-align:left">Short-hand middleware to set a key/value on the request context</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="extra-middlewares--packages" data-line="400" class="code-line">Extra middlewares &amp; packages</h3>
<p data-line="402" class="code-line">Please see <a href="https://github.com/go-chi" data-href="https://github.com/go-chi" title="https://github.com/go-chi">https://github.com/go-chi</a> for additional packages.</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:left">package</th>
<th style="text-align:left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/cors" data-href="https://github.com/go-chi/cors" title="https://github.com/go-chi/cors">cors</a></td>
<td style="text-align:left">Cross-origin resource sharing (CORS)</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/docgen" data-href="https://github.com/go-chi/docgen" title="https://github.com/go-chi/docgen">docgen</a></td>
<td style="text-align:left">Print chi.Router routes at runtime</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/jwtauth" data-href="https://github.com/go-chi/jwtauth" title="https://github.com/go-chi/jwtauth">jwtauth</a></td>
<td style="text-align:left">JWT authentication</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/hostrouter" data-href="https://github.com/go-chi/hostrouter" title="https://github.com/go-chi/hostrouter">hostrouter</a></td>
<td style="text-align:left">Domain/host based request routing</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/httplog" data-href="https://github.com/go-chi/httplog" title="https://github.com/go-chi/httplog">httplog</a></td>
<td style="text-align:left">Small but powerful structured HTTP request logging</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/httprate" data-href="https://github.com/go-chi/httprate" title="https://github.com/go-chi/httprate">httprate</a></td>
<td style="text-align:left">HTTP request rate limiter</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/httptracer" data-href="https://github.com/go-chi/httptracer" title="https://github.com/go-chi/httptracer">httptracer</a></td>
<td style="text-align:left">HTTP request performance tracing library</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/httpvcr" data-href="https://github.com/go-chi/httpvcr" title="https://github.com/go-chi/httpvcr">httpvcr</a></td>
<td style="text-align:left">Write deterministic tests for external sources</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/go-chi/stampede" data-href="https://github.com/go-chi/stampede" title="https://github.com/go-chi/stampede">stampede</a></td>
<td style="text-align:left">HTTP request coalescer</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="context" data-line="419" class="code-line">context?</h2>
<p data-line="421" class="code-line"><code>context</code> is a tiny pkg that provides simple interface to signal context across call stacks
and goroutines. It was originally written by <a href="https://github.com/Sajmani" data-href="https://github.com/Sajmani" title="https://github.com/Sajmani">Sameer Ajmani</a>
and is available in stdlib since go1.7.</p>
<p data-line="425" class="code-line">Learn more at <a href="https://blog.golang.org/context" data-href="https://blog.golang.org/context" title="https://blog.golang.org/context">https://blog.golang.org/context</a></p>
<p data-line="427" class="code-line">and..</p>
<ul>
<li data-line="428" class="code-line">Docs: <a href="https://golang.org/pkg/context" data-href="https://golang.org/pkg/context" title="https://golang.org/pkg/context">https://golang.org/pkg/context</a></li>
<li data-line="429" class="code-line">Source: <a href="https://github.com/golang/go/tree/master/src/context" data-href="https://github.com/golang/go/tree/master/src/context" title="https://github.com/golang/go/tree/master/src/context">https://github.com/golang/go/tree/master/src/context</a></li>
</ul>
<h2 id="benchmarks" data-line="432" class="code-line">Benchmarks</h2>
<p data-line="434" class="code-line">The benchmark suite: <a href="https://github.com/pkieltyka/go-http-routing-benchmark" data-href="https://github.com/pkieltyka/go-http-routing-benchmark" title="https://github.com/pkieltyka/go-http-routing-benchmark">https://github.com/pkieltyka/go-http-routing-benchmark</a></p>
<p data-line="436" class="code-line">Results as of Nov 29, 2020 with Go 1.15.5 on Linux AMD 3950x</p>
<pre><code data-line="438" class="code-line language-shell"><div>BenchmarkChi_Param          	3075895	        384 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_Param5         	2116603	        566 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_Param20        	 964117	       1227 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_ParamWrite     	2863413	        420 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GithubStatic   	3045488	        395 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GithubParam    	2204115	        540 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GithubAll      	  10000	     113811 ns/op	    81203 B/op    406 allocs/op
BenchmarkChi_GPlusStatic    	3337485	        359 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GPlusParam     	2825853	        423 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GPlus2Params   	2471697	        483 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_GPlusAll       	 194220	       5950 ns/op	     5200 B/op     26 allocs/op
BenchmarkChi_ParseStatic    	3365324	        356 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_ParseParam     	2976614	        404 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_Parse2Params   	2638084	        439 ns/op	      400 B/op      2 allocs/op
BenchmarkChi_ParseAll       	 109567	      11295 ns/op	    10400 B/op     52 allocs/op
BenchmarkChi_StaticAll      	  16846	      71308 ns/op	    62802 B/op    314 allocs/op
</div></code></pre>
<p data-line="457" class="code-line">Comparison with other routers: <a href="https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc" data-href="https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc" title="https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc">https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc</a></p>
<p data-line="459" class="code-line">NOTE: the allocs in the benchmark above are from the calls to http.Request's
<code>WithContext(context.Context)</code> method that clones the http.Request, sets the <code>Context()</code>
on the duplicated (alloc'd) request and returns it the new request object. This is just
how setting context on a request in Go works.</p>
<h2 id="credits" data-line="465" class="code-line">Credits</h2>
<ul>
<li data-line="467" class="code-line">Carl Jackson for <a href="https://github.com/zenazn/goji" data-href="https://github.com/zenazn/goji" title="https://github.com/zenazn/goji">https://github.com/zenazn/goji</a>
<ul>
<li data-line="468" class="code-line">Parts of chi's thinking comes from goji, and chi's middleware package
sources from goji.</li>
</ul>
</li>
<li data-line="470" class="code-line">Armon Dadgar for <a href="https://github.com/armon/go-radix" data-href="https://github.com/armon/go-radix" title="https://github.com/armon/go-radix">https://github.com/armon/go-radix</a></li>
<li data-line="471" class="code-line">Contributions: <a href="https://github.com/VojtechVitek" data-href="https://github.com/VojtechVitek" title="https://github.com/VojtechVitek">@VojtechVitek</a></li>
</ul>
<p data-line="473" class="code-line">We'll be more than happy to see <a href="./CONTRIBUTING.md" data-href="./CONTRIBUTING.md" title="./CONTRIBUTING.md">your contributions</a>!</p>
<h2 id="beyond-rest" data-line="476" class="code-line">Beyond REST</h2>
<p data-line="478" class="code-line">chi is just a http router that lets you decompose request handling into many smaller layers.
Many companies use chi to write REST services for their public APIs. But, REST is just a convention
for managing state via HTTP, and there's a lot of other pieces required to write a complete client-server
system or network of microservices.</p>
<p data-line="483" class="code-line">Looking beyond REST, I also recommend some newer works in the field:</p>
<ul>
<li data-line="484" class="code-line"><a href="https://github.com/webrpc/webrpc" data-href="https://github.com/webrpc/webrpc" title="https://github.com/webrpc/webrpc">webrpc</a> - Web-focused RPC client+server framework with code-gen</li>
<li data-line="485" class="code-line"><a href="https://github.com/grpc/grpc-go" data-href="https://github.com/grpc/grpc-go" title="https://github.com/grpc/grpc-go">gRPC</a> - Google's RPC framework via protobufs</li>
<li data-line="486" class="code-line"><a href="https://github.com/99designs/gqlgen" data-href="https://github.com/99designs/gqlgen" title="https://github.com/99designs/gqlgen">graphql</a> - Declarative query language</li>
<li data-line="487" class="code-line"><a href="https://nats.io" data-href="https://nats.io" title="https://nats.io">NATS</a> - lightweight pub-sub</li>
</ul>
<h2 id="license" data-line="490" class="code-line">License</h2>
<p data-line="492" class="code-line">Copyright (c) 2015-present <a href="https://github.com/pkieltyka" data-href="https://github.com/pkieltyka" title="https://github.com/pkieltyka">Peter Kieltyka</a></p>
<p data-line="494" class="code-line">Licensed under <a href="./LICENSE" data-href="./LICENSE" title="./LICENSE">MIT License</a></p>

        <div class="code-line" data-line="501"></div>
        

    </body>

</html>

